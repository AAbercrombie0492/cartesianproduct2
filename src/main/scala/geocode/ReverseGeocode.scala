package geocode

import org.apache.spark
import org.apache.spark._
import org.apache.spark.SparkContext
import org.apache.spark.SparkContext._
import org.apache.spark.SparkConf
import org.apache.spark.sql.cassandra
import org.apache.spark.sql.SparkSession
import com.datastax.spark
import com.datastax.spark._
import com.datastax.spark.connector
import com.datastax.spark.connector._
import com.datastax.spark.connector.cql
import com.datastax.spark.connector.cql._
import com.datastax.spark.connector.cql.CassandraConnector
import com.datastax.spark.connector.cql.CassandraConnector._
import com.datastax.spark.connector.rdd.CassandraTableScanRDD
import org.apache.spark.streaming._
import org.apache.spark.streaming.kafka010._
import org.apache.spark.streaming.kafka010.LocationStrategies.PreferConsistent
import org.apache.spark.streaming.kafka010.ConsumerStrategies.Subscribe
import org.apache.kafka.clients.consumer.ConsumerRecord
import org.apache.kafka.common.serialization.StringDeserializer

import scala.util.parsing.json.JSON.parseFull

import EasyJSON._
import EasyJSON.JSON.{parseJSON, makeJSON}
import EasyJSON.ScalaJSON
import EasyJSON.ScalaJSONIterator


/**
  * Created by AnthonyAbercrombie on 7/6/17.
  */
object ReverseGeocode {
  // Define Spark configuration
  val conf = new SparkConf().setMaster("local[2]").setAppName("spark_conf")
  // Define Spark Context, should identify and connect to a locally running cassandra database
  val sc = new SparkContext(conf) //.set(“spark.cassandra.connection.host”, “localhost”)


  /**
    * Executes a query that gets distinct lat/long pairs from the raw Plume Cassandra Table and returns a Sequence of
    * lat/long sets.
    */
  def QueryDistinctLatLongs() : Seq[Map[String, Double]] = {
    // Input : No input
    // OUTPUT : coordinates ---- Seq[Set]
    case class PlumeStationCoords(latitude: Double, longitude: Double)
    val rawGeoData: CassandraTableScanRDD[CassandraRow] = sc.cassandraTable("CartesianProduct", "geodictionary").select("latitude", "longitude")

    val cols: Array[String] = Array("latitude", "longitude") // Array of column names of the same type
    val latLongArrays = rawGeoData.map(row => cols.map(row.getDouble(_)))

    val coordinates = latLongArrays.map(x => Map("latitude" -> x(0), "longitude" -> x(1))).collect()
  coordinates
  }


  /**
    * Applies the GoogleMapsRequester helper function to a Sequence of lat/long pairs.
    * Organizes the results into the GeoDictionary Cassandra Table, which is created on the spot. The table
    * is composed with the following columns:
    *
    * latitude : Double
    * longitude: Double
    * country: String
    * political: String
    * administrative_1 : String
    * geodata : UDT --- ask Daniel Gorham
    *
    */
  case class geodata(latitude: Double, longitude: Double, geodata: String)
  def Geocoder(coordinates: Seq[Map[String, Double]]) : Unit = {
    // Input : coordinates ---- Sequence of unique lat/long pairs generated by GetDistinctLatLongs()
    // Output: GeoDictionary ---- Cassandra Table that maps each unique lat long to geographic metadata

    // I know doing 3 for loops is inefficient, this is just for clarity.
    val resultsSeq = for (point <- coordinates) yield parseJSON(GoogleMapsRequester(point("latitude"), point("longitude"), "AIzaSyCSnYlXKQbAmxoCZ4y8xtdD-JfCwADEuXI", "locality"))
    val geoSeq = for (tree <- resultsSeq) yield (tree.results(0).formatted_address, tree.results(0).geometry.location.lat, tree.results(0).geometry.location.long)
//    val geoSeqIterator = geoSeq.iterator()
    val geodataseq = for (geo <- geoSeq) yield geo
//    val geodataseq = for (geo <- geoSeq) yield new geodata(geo.apply(0), geo.apply(1), geo.apply(2))

    val geoRDD = sc.parallelize(geodataseq)
    println(geoRDD.getClass.getName)

//    geoRDD.saveToCassandraAs("CartesianProduct", "GeoDataDictionary", SomeColumns("latitude", "longitude", "geodata"))

  }

  /**
    * Takes a latitude coord [lat], a longitude coord [long],
    * Google Maps API key [GOOGLEMAPS], and a results_type (e.g. locality). These arguements are then
    *  factored into an API call. The results of the API call are then
    *  returned as a json string [googleMapsResult]
    */
  def GoogleMapsRequester(lat: Double, long: Double, GOOGLEMAPS: String, result_type: String) : String = {
    // Input: lat --- latitude, long --- longitude, GOOGLEMAPS --- API key
    // Output: googleMapsResult --- raw result from google maps API

    // Format inputs into a url string that will be used to request from a REST API
    val requestURL = f"https://maps.googleapis.com/maps/api/geocode/json?latlng=$lat%s,$long%s&result_type=$result_type%s&key=$GOOGLEMAPS%s"
    // Make an HTTP GET request to the requestURL and return the response as a string
    val googleMapsResult = scala.io.Source.fromURL(requestURL).mkString
    googleMapsResult
  }

}
